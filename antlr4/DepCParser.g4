/*
 * Copyright Raffaele Rossi 2023 - 2025.
 *
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
 */
parser grammar DepCParser;
options { tokenVocab=DepCLexer; }

// A brief explanation is probably due here.
// Whilst having target-specific code is not great for portability,
// the alternative is to have equivalent checks performed by the target parser.
// But that is even worse! At least now you can see where `one_of(...)` is used.
// If portability to another target language is needed, one could perhaps imagine
// having the entire `@parser::members` generated by some preprocessor like m4.
@parser::members
{
    template <typename... T>
    bool one_of(T const&... patterns)
    {
        if (((getCurrentToken()->getText() == patterns) or ...))
            return true;
        throw antlr4::FailedPredicateException(this, "one_of", mismatched_input({patterns...}));
        return false;
    }

    std::string mismatched_input(std::vector<std::string_view> const& expected)
    {
        std::ostringstream err;
        err << "mismatched input `" << getCurrentToken()->getText() << "` expecting ";
        bool first = true;
        for (auto const& x: expected)
            (std::exchange(first, false) ? err : err << ", ") << '`' << x << '`';
        return err.str();
    }
}

// Module and top level expressions
module: moduleEntry* EOF;
moduleEntry: typeDef | axiom | externDecl | funcDecl | funcDef;
axiom: 'axiom' name=ID funcType ';';
externDecl: 'extern' name=ID funcType ';';
funcSig: 'func' ('[[' attribute=ATTR ']]')? name=ID funcType;
funcDecl: funcSig ';';
funcDef: funcSig body;
typeDef: integerDef | structDef;
integerDef:
    'typedef' name=ID '='
    {one_of("signed", "unsigned")}? sign=ID
    {one_of("8", "16", "32", "64")}? width=INT
    {one_of("bit")}? ID
    {one_of("integer")}? ID
    SEMI;
structDef: 'struct' name=ID '{' (fieldDecl SEMI)* '}' SEMI;
fieldDecl: fieldType=expr fieldName=ID;

// Types
funcArg: ({one_of("0", "1")}? qty=INT)? ('typename' | expr) name=ID?;
type: primitiveType | funcType | tupleType | typeVar;
primitiveType: 'bool_t' | 'cstr_t' | 'unit_t' | 'i8_t' | 'i16_t' | 'i32_t' | 'i64_t' | 'u8_t' | 'u16_t' | 'u32_t' | 'u64_t';
funcType: '(' (funcArg (',' funcArg)*)? ')' 'mutable'? '->' ('typename' | retType=expr);
tupleType: '(' ')' | '(' funcArg ',' ')' | '(' funcArg (',' funcArg)+ ')';
typeVar: name=ID;

// Statements
body: '{' stmt* '}';

stmt: funcCallStmt | ifElse | returnStmt | impossibleStmt;

funcCallStmt: func=expr '(' (expr (',' expr)*)? ')' ';';
ifElse: 'if' '(' cond=expr ')' true_branch=bodyOrStmt ('else' false_branch=bodyOrStmt)?;
bodyOrStmt: body | stmt;
returnStmt: 'return' expr? ';';
impossibleStmt: 'impossible' ('because' expr)?';';

// Expressions
expr:
      func=expr '(' (expr (',' expr)*)? ')' # funcCallExpr
    | 'scopeof' '(' var=ID ')' # scopeExpr
    | expr ('.' | '->') field=ID # memberExpr
    | expr '[' expr ']' # subscriptExpr
    | '&' var=ID # addressOfExpr
    | '*' expr # derefExpr
    | value=expr 'because' reason=expr # becauseExpr
    | 'not' expr # notExpr
    | lhs=expr op=('*' | '/') rhs=expr # multOrDivExpr
    | lhs=expr op=('+' | '-') rhs=expr # plusOrMinusExpr
    | lhs=expr op=('<' | '<=' | '>' | '>=') rhs=expr # relationExpr
    | lhs=expr op=('==' | '!=') rhs=expr # equalityExpr
    | lhs=expr 'and' rhs=expr # andExpr
    | lhs=expr 'or' rhs=expr # orExpr
    | value=STR # stringLiteral
    | sign=('+' | '-')? value=INT # numericConstant
    | value=('true'|'false') # booleanConstant
    | ('array_t' | 'auto' | 'ref_t' | 'scope_t' | 'true_t') # kwExpr
    | module_name=ID? '::' symbol_name=ID # globalExpr
    | var=ID # varExpr
    | type # typeExpr // in an expression `f(x)` x should be parsed as `var` so this rule must come after `var`
    | '(' expr ')' # subExpr
    | '{' (expr (',' expr)*)? '}' # initListExpr
    ;
