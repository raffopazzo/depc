/*
 * Copyright Raffaele Rossi 2023 - 2024.
 *
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
 */
/**
 * @file
 * @brief Set of functions to generate LLVM values, for example constants and function calls.
 */
#pragma once

#include "private/context.hpp"
#include "private/gen_alloca.hpp"

#include "dep0/typecheck/ast.hpp"

#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Value.h>

namespace dep0::llvmgen {

/**
 * @brief Helper class that allows to generate an LLVM value in-place at some run-time location.
 *
 * When generating an LLVM value from `gen_val()`, there are two main situations:
 *
 * 1. We might want to generate some temporary value on the run-time stack,
 * for example if the result of `a + b` and pass it as an argument to a function call.
 *
 * 2. We might want to generate a value and store it at some run-time location,
 * for example if the result of `a + b` needs to be stored to the i-th element of some array.
 *
 * In addition, the value being generated might require memory to be allocated,
 * for example we might need to generate a tuple in-place somewhere and it might contain an array.
 * In this example we need to know whether memory for the array needs to be allocated
 * on the (run-time) stack or on the (run-time) heap.
 */
class value_storage_t
{
    llvm::Value* const m_dest;
    allocator_t m_allocator;

public:
    /** @brief Temporary storage for a run-time value on the stack. */
    value_storage_t() : m_dest(nullptr), m_allocator(allocator_t::stack) { }

    /** @brief Store a value at some run-time location and use the given allocator if it needs extra memory. */
    value_storage_t(llvm::Value& dest, allocator_t const allocator) : m_dest(&dest) , m_allocator(allocator) { }

    /**
     * @brief Returns the run-time location where the value needs to be stored,
     * or `nullptr` if we need to generate some tempoorary value on the stack.
     */
    llvm::Value* dest() const { return m_dest; }

    allocator_t allocator() const { return m_allocator; }
};

/** @brief Generates the value of the unit type. */
llvm::Value* gen_val_unit(global_ctx_t&);

/** @brief Generates an LLVM value for the given type and number. */
llvm::Value* gen_val(llvm::IntegerType*, boost::multiprecision::cpp_int const&);

/**
 * @brief Generates an LLVM value for the given expression.
 * @return The value generated if storage is temporary; otherwise the run-time location where the value was stored.
 */
llvm::Value* gen_val(
    global_ctx_t&,
    local_ctx_t const&,
    llvm::IRBuilder<>&,
    typecheck::expr_t const&,
    value_storage_t);

/**
 * @brief Generates LLVM instructions to `store/memcpy/memset` an LLVM value at some run-time location.
 *
 * The exact sequence of LLVM instructions generated by this function depends on the type of the value to store.
 * For example, for an `i32_t` a simple `store` is enough but for an `array_t(i32_t, n)` a `memcpy` might be necessary.
 *
 * @return The run-time location where the value is stored if one was supplied;
 * otherwise, if storage is temporary, `value` is returned and this function does nothing.
 */
llvm::Value* maybe_gen_store(
    global_ctx_t&,
    local_ctx_t const&,
    llvm::IRBuilder<>&,
    llvm::Value*,
    value_storage_t,
    typecheck::expr_t const& type);

/**
 * @brief Generates an LLVM value from a run-time function call corresponding to the given application expression.
 * @param dest If not `nullptr`, emit IR instructions as explained in `maybe_gen_store()`.
 * @return The value generated if storage is temporary; otherwise the run-time location where the value was stored.
 */
llvm::Value* gen_func_call(
    global_ctx_t&,
    local_ctx_t const&,
    llvm::IRBuilder<>&,
    typecheck::expr_t::app_t const&,
    value_storage_t);

} // namespace dep0::llvmgen
