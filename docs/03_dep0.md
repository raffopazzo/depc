# Dep0: AST and Pipeline

The **single most important** thing to be familiar with in Dep0 is the AST.
However, describing the Pipeline first and the AST later, might actually help in understanding the AST better.

## Pipeline

The pipeline is fairly standard:

```
             ----------    ----------------    -------------    ---------------    -----------------
file.depc -> | parser | -> | typechecking | -> | transform | -> | LLVM IR gen | -> | LLVM Pipeline | -> file.o
             ----------    ----------------    -------------    ---------------    -----------------
```

A source file is mmap-ed and passed to the parser.
If parsing is successful, the parser produces a `parser::module_t`, i.e. the root node of the AST representing an entire module.
The "parser AST" is then passed to the typechecking stage which, if successful, produces a `typecheck::module_t`, i.e. a "legal AST"
(in Type Theory an expression is called legal if it can be assigned a type, hence the name "legal AST").
Once you have a "legal AST" the job is essentially done.
The transform stage can perform various transformations on the legal AST, all of which modify the AST in place "without breaking it", i.e. it stays a "legal AST".
The LLVM IR gen stage receives a (possibly transformed) "legal AST", i.e. a `typecheck::module_t`, and produces an LLVM module.
Finally, the LLVM module is passed to the LLVM Pipeline where the LLVM IR gets optimised and the final object code emitted.

## AST

From the above description it is hopefully clear that all stages of the Dep0 pipeline,
from parser to LLVM IR gen, operate (or produce) an AST.
This AST is either:
* a "parser AST", which merely represents the input source code as a data structure in memory;
quite obviously the source code did not contain any parsing error, else you would not have a "parser AST" at all,
but it may still contain compilation errors (aka typechecking errors);
* a "legal AST", which means that the source code is valid, i.e. it does not contain any typechecking error.

Because of this double usage, the AST is actually a template.
The template parameter is a `Properties` traits indicating, for each type of the AST node,
the properties that apply to that specific node for the current pipeline stage.
For example, if there is an expression `a + b` somewhere in the source code,
the parser stage will produce an AST that will contain a node representing `a + b`.
The properties of this node will contain the location in the text file where the string `a + b` was located.
After typechecking, a new AST is produced, which will obviously also contain a node for `a + b`.
Now though the properties of this node will contain the type of this expression.
For more details, take a look at [ast.hpp](/dep0/lib/01_ast/include/dep0/ast/ast.hpp).
