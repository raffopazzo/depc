/*
 * Copyright Raffaele Rossi 2023 - 2025.
 *
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
 */
func f1((u64_t n, array_t(i32_t, n)) x) -> i32_t
{
    if (2 < x[0])
        return x[1][2];
    else
       return 0;
}

func f2() -> (u64_t n, array_t(i32_t, n))
{
    // the caller allocates the return value of type `{i64, i32*}` on the stack
    // but the array `{1,2,3}` is allocated on the heap
   return {3, {1,2,3}};
}

func extract((u64_t n, array_t(i32_t, n)) x) -> array_t(i32_t, x[0])
{
    return x[1];
}

func f3() -> array_t(i32_t, 3)
{
    // here the array `{1,2,3}` is also allocated on the stack and memcpy'd into the caller's return value
    return extract({3, {1,2,3}});
}

func f4() -> array_t((u64_t n, array_t(i32_t, n)), 3)
{
    // the caller passes a return value, which is just a pointer;
    // the arrays inside each entry are all heap-allocated;
    // their pointers are stored directly without memcpy
    return {f2(), f2(), f2()};
}
